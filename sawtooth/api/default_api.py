# coding: utf-8

"""
    Sawtooth REST API

    _This HTTP pragmatic REST API is built on top of Sawtooth's existing ZMQ/Protobuf infrastructure, simplifying client interaction with the blockchain by exposing endpoints that use common HTTP/JSON standards._   # noqa: E501

    OpenAPI spec version: 0.8.0
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from swagger_client.api_client import ApiClient


class DefaultApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def batch_statuses_get(self, id, **kwargs):  # noqa: E501
        """Fetches the committed statuses for a set of batches  # noqa: E501

        Fetches an array of objects with a status and id for each batch requested. There are four possible statuses with string values `'COMMITTED'`, `'INVALID'`, `'PENDING'`, and `'UNKNOWN'`.  The batch(es) you want to check can be specified using the `id` filter parameter. If a `wait` time is specified in the URL, the API will wait to respond until all batches are committed, or the time in seconds has elapsed. If the value of `wait` is not set (i.e., `?wait&id=...`), or it is set to any non-integer value other than `false`, the wait time will be just under the API's specified timeout (usually 300).  Note that because this route does not return full resources, the response will not be paginated, and there will be no `head` or `paging` properties.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.batch_statuses_get(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: A comma-separated list of batch ids (required)
        :param int wait: A time in seconds to wait for commit
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.batch_statuses_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.batch_statuses_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def batch_statuses_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Fetches the committed statuses for a set of batches  # noqa: E501

        Fetches an array of objects with a status and id for each batch requested. There are four possible statuses with string values `'COMMITTED'`, `'INVALID'`, `'PENDING'`, and `'UNKNOWN'`.  The batch(es) you want to check can be specified using the `id` filter parameter. If a `wait` time is specified in the URL, the API will wait to respond until all batches are committed, or the time in seconds has elapsed. If the value of `wait` is not set (i.e., `?wait&id=...`), or it is set to any non-integer value other than `false`, the wait time will be just under the API's specified timeout (usually 300).  Note that because this route does not return full resources, the response will not be paginated, and there will be no `head` or `paging` properties.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.batch_statuses_get_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: A comma-separated list of batch ids (required)
        :param int wait: A time in seconds to wait for commit
        :return: InlineResponse2002
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'wait']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method batch_statuses_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `batch_statuses_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
        if 'wait' in params:
            query_params.append(('wait', params['wait']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/batch_statuses', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2002',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def batch_statuses_post(self, batch_ids, **kwargs):  # noqa: E501
        """Fetches the committed statuses for a set of batches  # noqa: E501

        Identical to `GET /batch_statuses`, but takes ids of batches as a JSON formatted POST body rather than a query parameter. This allows for many more batches to be checked and should be used for more than 15 ids.  Note that because query information is not encoded in the URL, no `link` will be returned with this query.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.batch_statuses_post(batch_ids, async=True)
        >>> result = thread.get()

        :param async bool
        :param list[str] batch_ids: A JSON array of batch id strings (required)
        :param int wait: A time in seconds to wait for commit
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.batch_statuses_post_with_http_info(batch_ids, **kwargs)  # noqa: E501
        else:
            (data) = self.batch_statuses_post_with_http_info(batch_ids, **kwargs)  # noqa: E501
            return data

    def batch_statuses_post_with_http_info(self, batch_ids, **kwargs):  # noqa: E501
        """Fetches the committed statuses for a set of batches  # noqa: E501

        Identical to `GET /batch_statuses`, but takes ids of batches as a JSON formatted POST body rather than a query parameter. This allows for many more batches to be checked and should be used for more than 15 ids.  Note that because query information is not encoded in the URL, no `link` will be returned with this query.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.batch_statuses_post_with_http_info(batch_ids, async=True)
        >>> result = thread.get()

        :param async bool
        :param list[str] batch_ids: A JSON array of batch id strings (required)
        :param int wait: A time in seconds to wait for commit
        :return: InlineResponse2003
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['batch_ids', 'wait']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method batch_statuses_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'batch_ids' is set
        if ('batch_ids' not in params or
                params['batch_ids'] is None):
            raise ValueError("Missing the required parameter `batch_ids` when calling `batch_statuses_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'wait' in params:
            query_params.append(('wait', params['wait']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'batch_ids' in params:
            body_params = params['batch_ids']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/batch_statuses', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2003',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def batches_batch_id_get(self, batch_id, **kwargs):  # noqa: E501
        """Fetches a particular batch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.batches_batch_id_get(batch_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str batch_id: Batch id (required)
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.batches_batch_id_get_with_http_info(batch_id, **kwargs)  # noqa: E501
        else:
            (data) = self.batches_batch_id_get_with_http_info(batch_id, **kwargs)  # noqa: E501
            return data

    def batches_batch_id_get_with_http_info(self, batch_id, **kwargs):  # noqa: E501
        """Fetches a particular batch  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.batches_batch_id_get_with_http_info(batch_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str batch_id: Batch id (required)
        :return: InlineResponse2001
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['batch_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method batches_batch_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'batch_id' is set
        if ('batch_id' not in params or
                params['batch_id'] is None):
            raise ValueError("Missing the required parameter `batch_id` when calling `batches_batch_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'batch_id' in params:
            path_params['batch_id'] = params['batch_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/batches/{batch_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2001',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def batches_get(self, **kwargs):  # noqa: E501
        """Fetches a list of batches  # noqa: E501

        Fetches a paginated list of batches from the validator.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.batches_get(async=True)
        >>> result = thread.get()

        :param async bool
        :param str head: Index or id of head block
        :param str start: Id to start paging (inclusive)
        :param int limit: Number of items to return
        :param str reverse: If the list should be reversed
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.batches_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.batches_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def batches_get_with_http_info(self, **kwargs):  # noqa: E501
        """Fetches a list of batches  # noqa: E501

        Fetches a paginated list of batches from the validator.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.batches_get_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str head: Index or id of head block
        :param str start: Id to start paging (inclusive)
        :param int limit: Number of items to return
        :param str reverse: If the list should be reversed
        :return: InlineResponse200
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['head', 'start', 'limit', 'reverse']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method batches_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'head' in params:
            query_params.append(('head', params['head']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'reverse' in params:
            query_params.append(('reverse', params['reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/batches', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse200',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def batches_post(self, batch_list, **kwargs):  # noqa: E501
        """Sends a BatchList to the validator  # noqa: E501

        Accepts a protobuf formatted `BatchList` as an octet-stream binary file and submits it to the validator to be committed.  The API will return immediately with a status of `202`. There will be no `data` object, only a `link` to a `/batch_statuses` endpoint to be polled to check the status of submitted batches.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.batches_post(batch_list, async=True)
        >>> result = thread.get()

        :param async bool
        :param BatchList batch_list: A binary encoded protobuf BatchList (required)
        :return: InlineResponse202
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.batches_post_with_http_info(batch_list, **kwargs)  # noqa: E501
        else:
            (data) = self.batches_post_with_http_info(batch_list, **kwargs)  # noqa: E501
            return data

    def batches_post_with_http_info(self, batch_list, **kwargs):  # noqa: E501
        """Sends a BatchList to the validator  # noqa: E501

        Accepts a protobuf formatted `BatchList` as an octet-stream binary file and submits it to the validator to be committed.  The API will return immediately with a status of `202`. There will be no `data` object, only a `link` to a `/batch_statuses` endpoint to be polled to check the status of submitted batches.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.batches_post_with_http_info(batch_list, async=True)
        >>> result = thread.get()

        :param async bool
        :param BatchList batch_list: A binary encoded protobuf BatchList (required)
        :return: InlineResponse202
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['batch_list']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method batches_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'batch_list' is set
        if ('batch_list' not in params or
                params['batch_list'] is None):
            raise ValueError("Missing the required parameter `batch_list` when calling `batches_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'batch_list' in params:
            body_params = params['batch_list']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/octet-stream'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/batches', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse202',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def blocks_block_id_get(self, block_id, **kwargs):  # noqa: E501
        """Fetches a particular block  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.blocks_block_id_get(block_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str block_id: Block id (required)
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.blocks_block_id_get_with_http_info(block_id, **kwargs)  # noqa: E501
        else:
            (data) = self.blocks_block_id_get_with_http_info(block_id, **kwargs)  # noqa: E501
            return data

    def blocks_block_id_get_with_http_info(self, block_id, **kwargs):  # noqa: E501
        """Fetches a particular block  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.blocks_block_id_get_with_http_info(block_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str block_id: Block id (required)
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['block_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method blocks_block_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'block_id' is set
        if ('block_id' not in params or
                params['block_id'] is None):
            raise ValueError("Missing the required parameter `block_id` when calling `blocks_block_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'block_id' in params:
            path_params['block_id'] = params['block_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/blocks/{block_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2007',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def blocks_get(self, **kwargs):  # noqa: E501
        """Fetches a list of blocks  # noqa: E501

        Fetches a paginated list of blocks from the validator.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.blocks_get(async=True)
        >>> result = thread.get()

        :param async bool
        :param str head: Index or id of head block
        :param str start: Id to start paging (inclusive)
        :param int limit: Number of items to return
        :param str reverse: If the list should be reversed
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.blocks_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.blocks_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def blocks_get_with_http_info(self, **kwargs):  # noqa: E501
        """Fetches a list of blocks  # noqa: E501

        Fetches a paginated list of blocks from the validator.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.blocks_get_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str head: Index or id of head block
        :param str start: Id to start paging (inclusive)
        :param int limit: Number of items to return
        :param str reverse: If the list should be reversed
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['head', 'start', 'limit', 'reverse']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method blocks_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'head' in params:
            query_params.append(('head', params['head']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'reverse' in params:
            query_params.append(('reverse', params['reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/blocks', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2006',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def peers_get(self, **kwargs):  # noqa: E501
        """Fetches the endpoints of the authorized peers of the validator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.peers_get(async=True)
        >>> result = thread.get()

        :param async bool
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.peers_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.peers_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def peers_get_with_http_info(self, **kwargs):  # noqa: E501
        """Fetches the endpoints of the authorized peers of the validator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.peers_get_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: InlineResponse2009
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method peers_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/peers', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2009',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def receipts_get(self, id, **kwargs):  # noqa: E501
        """Fetches the receipts for a set of transactions  # noqa: E501

        Fetches an array of objects for each receipt requested.  The receipt(s) you want to retrieve can be specified using the `id` filter parameter, where `id` refers to the transaction id of the transaction the receipt is associated with.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.receipts_get(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: A comma-separated list of transaction ids (required)
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.receipts_get_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.receipts_get_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def receipts_get_with_http_info(self, id, **kwargs):  # noqa: E501
        """Fetches the receipts for a set of transactions  # noqa: E501

        Fetches an array of objects for each receipt requested.  The receipt(s) you want to retrieve can be specified using the `id` filter parameter, where `id` refers to the transaction id of the transaction the receipt is associated with.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.receipts_get_with_http_info(id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str id: A comma-separated list of transaction ids (required)
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method receipts_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `receipts_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/receipts', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2008',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def receipts_post(self, transaction_ids, **kwargs):  # noqa: E501
        """Fetches the receipts for a set of transactions  # noqa: E501

        Identical to `GET /receipts`, but takes ids of transactions as a JSON formatted POST body rather than a query parameter. This allows for many more receipts to be fetched and should be used with more than 15 ids.  Note that because query information is not encoded in the URL, no `link` will be returned with this request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.receipts_post(transaction_ids, async=True)
        >>> result = thread.get()

        :param async bool
        :param list[str] transaction_ids: A JSON array of transaction id strings (required)
        :param int wait: A time in seconds to wait for commit
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.receipts_post_with_http_info(transaction_ids, **kwargs)  # noqa: E501
        else:
            (data) = self.receipts_post_with_http_info(transaction_ids, **kwargs)  # noqa: E501
            return data

    def receipts_post_with_http_info(self, transaction_ids, **kwargs):  # noqa: E501
        """Fetches the receipts for a set of transactions  # noqa: E501

        Identical to `GET /receipts`, but takes ids of transactions as a JSON formatted POST body rather than a query parameter. This allows for many more receipts to be fetched and should be used with more than 15 ids.  Note that because query information is not encoded in the URL, no `link` will be returned with this request.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.receipts_post_with_http_info(transaction_ids, async=True)
        >>> result = thread.get()

        :param async bool
        :param list[str] transaction_ids: A JSON array of transaction id strings (required)
        :param int wait: A time in seconds to wait for commit
        :return: InlineResponse2008
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transaction_ids', 'wait']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method receipts_post" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transaction_ids' is set
        if ('transaction_ids' not in params or
                params['transaction_ids'] is None):
            raise ValueError("Missing the required parameter `transaction_ids` when calling `receipts_post`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'wait' in params:
            query_params.append(('wait', params['wait']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'transaction_ids' in params:
            body_params = params['transaction_ids']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/receipts', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2008',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def state_address_get(self, address, **kwargs):  # noqa: E501
        """Fetches a particular leaf from the current state  # noqa: E501

        Takes full 70-character address and fetches a particular leaf. For partial address (i.e., group of leaves) use `/state` above.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.state_address_get(address, async=True)
        >>> result = thread.get()

        :param async bool
        :param str address: Radix address of a leaf (required)
        :param str head: Index or id of head block
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.state_address_get_with_http_info(address, **kwargs)  # noqa: E501
        else:
            (data) = self.state_address_get_with_http_info(address, **kwargs)  # noqa: E501
            return data

    def state_address_get_with_http_info(self, address, **kwargs):  # noqa: E501
        """Fetches a particular leaf from the current state  # noqa: E501

        Takes full 70-character address and fetches a particular leaf. For partial address (i.e., group of leaves) use `/state` above.    # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.state_address_get_with_http_info(address, async=True)
        >>> result = thread.get()

        :param async bool
        :param str address: Radix address of a leaf (required)
        :param str head: Index or id of head block
        :return: InlineResponse2005
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['address', 'head']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method state_address_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'address' is set
        if ('address' not in params or
                params['address'] is None):
            raise ValueError("Missing the required parameter `address` when calling `state_address_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'address' in params:
            path_params['address'] = params['address']  # noqa: E501

        query_params = []
        if 'head' in params:
            query_params.append(('head', params['head']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/state/{address}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2005',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def state_get(self, **kwargs):  # noqa: E501
        """Fetches the data for the current state  # noqa: E501

        Fetches a paginated list of entries for the current state, or relative to a particular head block. Using the `address` filter parameter will narrow the list to any entries that have an address beginning with the characters specified. Note that the partial address in `address` parameter should have even  number of hecadeximal characters (i.e., complete bytes).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.state_get(async=True)
        >>> result = thread.get()

        :param async bool
        :param str head: Index or id of head block
        :param str address: A partial address to filter leaves by
        :param str start: Id to start paging (inclusive)
        :param int limit: Number of items to return
        :param str reverse: If the list should be reversed
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.state_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.state_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def state_get_with_http_info(self, **kwargs):  # noqa: E501
        """Fetches the data for the current state  # noqa: E501

        Fetches a paginated list of entries for the current state, or relative to a particular head block. Using the `address` filter parameter will narrow the list to any entries that have an address beginning with the characters specified. Note that the partial address in `address` parameter should have even  number of hecadeximal characters (i.e., complete bytes).   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.state_get_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str head: Index or id of head block
        :param str address: A partial address to filter leaves by
        :param str start: Id to start paging (inclusive)
        :param int limit: Number of items to return
        :param str reverse: If the list should be reversed
        :return: InlineResponse2004
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['head', 'address', 'start', 'limit', 'reverse']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method state_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'head' in params:
            query_params.append(('head', params['head']))  # noqa: E501
        if 'address' in params:
            query_params.append(('address', params['address']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'reverse' in params:
            query_params.append(('reverse', params['reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/state', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2004',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def status_get(self, **kwargs):  # noqa: E501
        """Fetches information pertaining to the status of the validator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.status_get(async=True)
        >>> result = thread.get()

        :param async bool
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.status_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.status_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def status_get_with_http_info(self, **kwargs):  # noqa: E501
        """Fetches information pertaining to the status of the validator  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.status_get_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :return: InlineResponse20010
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method status_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/status', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse20010',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def transactions_get(self, **kwargs):  # noqa: E501
        """Fetches a list of transactions  # noqa: E501

        Fetches a paginated list of transactions from the validator.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.transactions_get(async=True)
        >>> result = thread.get()

        :param async bool
        :param str head: Index or id of head block
        :param str start: Id to start paging (inclusive)
        :param int limit: Number of items to return
        :param str reverse: If the list should be reversed
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.transactions_get_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.transactions_get_with_http_info(**kwargs)  # noqa: E501
            return data

    def transactions_get_with_http_info(self, **kwargs):  # noqa: E501
        """Fetches a list of transactions  # noqa: E501

        Fetches a paginated list of transactions from the validator.   # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.transactions_get_with_http_info(async=True)
        >>> result = thread.get()

        :param async bool
        :param str head: Index or id of head block
        :param str start: Id to start paging (inclusive)
        :param int limit: Number of items to return
        :param str reverse: If the list should be reversed
        :return: InlineResponse2006
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['head', 'start', 'limit', 'reverse']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transactions_get" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'head' in params:
            query_params.append(('head', params['head']))  # noqa: E501
        if 'start' in params:
            query_params.append(('start', params['start']))  # noqa: E501
        if 'limit' in params:
            query_params.append(('limit', params['limit']))  # noqa: E501
        if 'reverse' in params:
            query_params.append(('reverse', params['reverse']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/transactions', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2006',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def transactions_transaction_id_get(self, transaction_id, **kwargs):  # noqa: E501
        """Fetches a particular transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.transactions_transaction_id_get(transaction_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str transaction_id: Transaction id (required)
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async'):
            return self.transactions_transaction_id_get_with_http_info(transaction_id, **kwargs)  # noqa: E501
        else:
            (data) = self.transactions_transaction_id_get_with_http_info(transaction_id, **kwargs)  # noqa: E501
            return data

    def transactions_transaction_id_get_with_http_info(self, transaction_id, **kwargs):  # noqa: E501
        """Fetches a particular transaction  # noqa: E501

        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async=True
        >>> thread = api.transactions_transaction_id_get_with_http_info(transaction_id, async=True)
        >>> result = thread.get()

        :param async bool
        :param str transaction_id: Transaction id (required)
        :return: InlineResponse2007
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['transaction_id']  # noqa: E501
        all_params.append('async')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method transactions_transaction_id_get" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'transaction_id' is set
        if ('transaction_id' not in params or
                params['transaction_id'] is None):
            raise ValueError("Missing the required parameter `transaction_id` when calling `transactions_transaction_id_get`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'transaction_id' in params:
            path_params['transaction_id'] = params['transaction_id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = []  # noqa: E501

        return self.api_client.call_api(
            '/transactions/{transaction_id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='InlineResponse2007',  # noqa: E501
            auth_settings=auth_settings,
            async=params.get('async'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
